package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&VulkanTemplate{})
}

// VulkanTemplate generates a Vulkan graphics application
type VulkanTemplate struct {
	BaseTemplateHelper
}

func (t *VulkanTemplate) Name() string {
	return "Vulkan"
}

func (t *VulkanTemplate) Description() string {
	return "Graphics application with Vulkan + GLFW"
}

func (t *VulkanTemplate) Dependencies() []string {
	return []string{"vulkan", "glfw3", "glm"}
}

func (t *VulkanTemplate) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"src",
		"shaders",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate main.cpp
	mainCpp := t.generateMainCpp(projectName)
	if err := t.WriteFile(projectName, "src/main.cpp", mainCpp); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *VulkanTemplate) generateMainCpp(projectName string) string {
	return fmt.Sprintf(`// %s - Vulkan Application
// Generated by cpx

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include <iostream>
#include <stdexcept>
#include <cstdlib>
#include <vector>
#include <cstring>
#include <optional>

const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;

const std::vector<const char*> validationLayers = {
    "VK_LAYER_KHRONOS_validation"
};

#ifdef NDEBUG
const bool enableValidationLayers = false;
#else
const bool enableValidationLayers = true;
#endif

class VulkanApp {
public:
    void run() {
        initWindow();
        initVulkan();
        mainLoop();
        cleanup();
    }

private:
    GLFWwindow* window = nullptr;
    VkInstance instance = VK_NULL_HANDLE;

    void initWindow() {
        glfwInit();
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

        window = glfwCreateWindow(WIDTH, HEIGHT, "%s - Vulkan", nullptr, nullptr);
    }

    void initVulkan() {
        createInstance();
    }

    void createInstance() {
        bool useValidation = enableValidationLayers && checkValidationLayerSupport();
        if (enableValidationLayers && !useValidation) {
            std::cout << "Warning: Validation layers requested but not available. "
                      << "Install Vulkan SDK for validation support.\n";
        }

        VkApplicationInfo appInfo{};
        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
        appInfo.pApplicationName = "%s";
        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.pEngineName = "No Engine";
        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.apiVersion = VK_API_VERSION_1_0;

        VkInstanceCreateInfo createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        createInfo.pApplicationInfo = &appInfo;

        auto extensions = getRequiredExtensions();
        createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());
        createInfo.ppEnabledExtensionNames = extensions.data();

        if (useValidation) {
            createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
            createInfo.ppEnabledLayerNames = validationLayers.data();
            std::cout << "Validation layers enabled.\n";
        } else {
            createInfo.enabledLayerCount = 0;
        }

        // macOS portability extension
#ifdef __APPLE__
        createInfo.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
#endif

        if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
            throw std::runtime_error("Failed to create Vulkan instance!");
        }

        std::cout << "Vulkan instance created successfully!" << std::endl;
        listExtensions();
    }

    void listExtensions() {
        uint32_t extensionCount = 0;
        vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);

        std::vector<VkExtensionProperties> extensions(extensionCount);
        vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data());

        std::cout << "\nAvailable Vulkan extensions (" << extensionCount << "):\n";
        for (const auto& extension : extensions) {
            std::cout << "  " << extension.extensionName << std::endl;
        }
    }

    std::vector<const char*> getRequiredExtensions() {
        uint32_t glfwExtensionCount = 0;
        const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

        std::vector<const char*> extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);

#ifdef __APPLE__
        extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
        extensions.push_back("VK_KHR_get_physical_device_properties2");
#endif

        return extensions;
    }

    bool checkValidationLayerSupport() {
        uint32_t layerCount;
        vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

        std::vector<VkLayerProperties> availableLayers(layerCount);
        vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

        for (const char* layerName : validationLayers) {
            bool layerFound = false;

            for (const auto& layerProperties : availableLayers) {
                if (strcmp(layerName, layerProperties.layerName) == 0) {
                    layerFound = true;
                    break;
                }
            }

            if (!layerFound) {
                return false;
            }
        }

        return true;
    }

    void mainLoop() {
        std::cout << "\nRunning main loop. Press ESC or close window to exit.\n" << std::endl;

        while (!glfwWindowShouldClose(window)) {
            glfwPollEvents();

            if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
                glfwSetWindowShouldClose(window, GLFW_TRUE);
            }
        }
    }

    void cleanup() {
        vkDestroyInstance(instance, nullptr);
        glfwDestroyWindow(window);
        glfwTerminate();

        std::cout << "Cleanup complete." << std::endl;
    }
};

int main() {
    VulkanApp app;

    try {
        app.run();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
`, projectName, projectName, projectName)
}

func (t *VulkanTemplate) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find packages
find_package(Vulkan REQUIRED)
find_package(glfw3 CONFIG REQUIRED)
find_package(glm CONFIG REQUIRED)

# Add executable
add_executable(${PROJECT_NAME}
    src/main.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(${PROJECT_NAME} PRIVATE
    Vulkan::Vulkan
    glfw
    glm::glm
)

# macOS: Link to MoltenVK portability layer
if(APPLE)
    target_compile_definitions(${PROJECT_NAME} PRIVATE VK_USE_PLATFORM_MACOS_MVK)
endif()

# Copy compile_commands.json to project root
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_BINARY_DIR}/compile_commands.json
        ${CMAKE_SOURCE_DIR}/compile_commands.json
    )
endif()
`, projectName, cppStandard)
}

func (t *VulkanTemplate) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

A Vulkan graphics application with GLFW window management.

## Prerequisites

- Vulkan SDK (1.0+)
- For macOS: MoltenVK is used via vcpkg

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Running

`+"```"+`bash
cpx run
`+"```"+`

## Features

- Vulkan instance creation
- Validation layers (debug builds)
- GLFW window with Vulkan surface support
- Extension enumeration
- Cross-platform (Windows, Linux, macOS via MoltenVK)

## Controls

- **ESC**: Exit application

## Dependencies

- Vulkan SDK
- GLFW3
- GLM (OpenGL Mathematics)

## Project Structure

`+"```"+`
%s/
├── src/
│   └── main.cpp       # Vulkan initialization
├── shaders/           # GLSL shaders (add your own)
├── include/
│   └── %s/
│       └── version.hpp
└── CMakeLists.txt
`+"```"+`

## Next Steps

To extend this template into a full Vulkan renderer:

1. Add physical device selection
2. Create logical device and queues
3. Set up swap chain
4. Create render pass and pipeline
5. Add shaders (compile with glslc)
6. Implement command buffers
7. Add synchronization objects

## Resources

- [Vulkan Tutorial](https://vulkan-tutorial.com/)
- [Vulkan Specification](https://www.khronos.org/registry/vulkan/specs/)

## License

MIT
`, projectName, projectName, projectName)
}
