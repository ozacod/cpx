package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&CLITemplate{})
}

// CLITemplate generates a CLI application with CLI11
type CLITemplate struct {
	BaseTemplateHelper
}

func (t *CLITemplate) Name() string {
	return "CLI App"
}

func (t *CLITemplate) Description() string {
	return "Command-line application with CLI11"
}

func (t *CLITemplate) Dependencies() []string {
	return []string{"cli11", "fmt"}
}

func (t *CLITemplate) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"src",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate main.cpp
	mainCpp := t.generateMainCpp(projectName)
	if err := t.WriteFile(projectName, "src/main.cpp", mainCpp); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *CLITemplate) generateMainCpp(projectName string) string {
	return fmt.Sprintf(`// %s - CLI Application
// Generated by cpx

#include <CLI/CLI.hpp>
#include <fmt/core.h>
#include <fmt/color.h>
#include <%s/version.hpp>
#include <string>
#include <vector>
#include <filesystem>

namespace fs = std::filesystem;

// Example command: greet
void runGreet(const std::string& name, int count, bool uppercase) {
    for (int i = 0; i < count; ++i) {
        std::string greeting = fmt::format("Hello, {}!", name);
        if (uppercase) {
            std::transform(greeting.begin(), greeting.end(), greeting.begin(), ::toupper);
        }
        fmt::print(fmt::fg(fmt::color::green), "{}\n", greeting);
    }
}

// Example command: list
void runList(const std::string& path, bool recursive, bool showHidden) {
    fs::path targetPath = path.empty() ? fs::current_path() : fs::path(path);

    if (!fs::exists(targetPath)) {
        fmt::print(fmt::fg(fmt::color::red), "Error: Path '{}' does not exist\n", path);
        return;
    }

    fmt::print(fmt::fg(fmt::color::cyan), "Contents of: {}\n\n", targetPath.string());

    auto iterate = [&](const fs::directory_entry& entry) {
        std::string name = entry.path().filename().string();
        if (!showHidden && name[0] == '.') return;

        if (entry.is_directory()) {
            fmt::print(fmt::fg(fmt::color::blue), "  [DIR]  {}\n", name);
        } else {
            auto size = fs::file_size(entry.path());
            fmt::print("  [FILE] {} ({} bytes)\n", name, size);
        }
    };

    if (recursive) {
        for (const auto& entry : fs::recursive_directory_iterator(targetPath)) {
            iterate(entry);
        }
    } else {
        for (const auto& entry : fs::directory_iterator(targetPath)) {
            iterate(entry);
        }
    }
}

int main(int argc, char** argv) {
    CLI::App app{"%s - A sample CLI application"};
    app.set_version_flag("-v,--version", std::string(%s_VERSION));

    // Global options
    bool verbose = false;
    app.add_flag("--verbose", verbose, "Enable verbose output");

    // Subcommand: greet
    auto* greet = app.add_subcommand("greet", "Greet someone");
    std::string name = "World";
    int count = 1;
    bool uppercase = false;
    greet->add_option("-n,--name", name, "Name to greet")->default_val("World");
    greet->add_option("-c,--count", count, "Number of greetings")->default_val(1);
    greet->add_flag("-u,--uppercase", uppercase, "Print in uppercase");
    greet->callback([&]() {
        if (verbose) {
            fmt::print("Running greet command with name='{}', count={}\n", name, count);
        }
        runGreet(name, count, uppercase);
    });

    // Subcommand: list
    auto* list = app.add_subcommand("list", "List directory contents");
    std::string listPath;
    bool recursive = false;
    bool showHidden = false;
    list->add_option("path", listPath, "Path to list")->default_val(".");
    list->add_flag("-r,--recursive", recursive, "List recursively");
    list->add_flag("-a,--all", showHidden, "Show hidden files");
    list->callback([&]() {
        if (verbose) {
            fmt::print("Running list command on path='{}'\n", listPath);
        }
        runList(listPath, recursive, showHidden);
    });

    // Subcommand: info
    auto* info = app.add_subcommand("info", "Show application info");
    info->callback([&]() {
        fmt::print(fmt::fg(fmt::color::yellow), "\n  %s\n");
        fmt::print("  Version: {}\n", %s_VERSION);
        fmt::print("  Built with CLI11 and fmt\n\n");
    });

    // Require at least one subcommand
    app.require_subcommand(1);

    CLI11_PARSE(app, argc, argv);

    return 0;
}
`, projectName, projectName, projectName, toUpperSnakeCase(projectName), projectName, toUpperSnakeCase(projectName))
}

func (t *CLITemplate) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find packages
find_package(CLI11 CONFIG REQUIRED)
find_package(fmt CONFIG REQUIRED)

# Add executable
add_executable(${PROJECT_NAME}
    src/main.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(${PROJECT_NAME} PRIVATE
    CLI11::CLI11
    fmt::fmt
)

# Copy compile_commands.json to project root
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_BINARY_DIR}/compile_commands.json
        ${CMAKE_SOURCE_DIR}/compile_commands.json
    )
endif()
`, projectName, cppStandard)
}

func (t *CLITemplate) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

A command-line application built with CLI11 and fmt.

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Usage

`+"```"+`bash
# Show help
./%s --help

# Show version
./%s --version

# Greet command
./%s greet --name "Alice" --count 3
./%s greet -n Bob -u

# List directory
./%s list
./%s list /path/to/dir -r -a

# Show info
./%s info
`+"```"+`

## Commands

| Command | Description |
|---------|-------------|
| greet | Greet someone with customizable options |
| list | List directory contents |
| info | Show application information |

## Global Options

| Option | Description |
|--------|-------------|
| --verbose | Enable verbose output |
| -v, --version | Show version |
| -h, --help | Show help |

## Dependencies

- CLI11 (command-line parsing)
- fmt (formatting library)

## Adding New Commands

1. Create a new subcommand with `+"`app.add_subcommand()`"+`
2. Add options with `+"`add_option()`"+` and `+"`add_flag()`"+`
3. Set callback with `+"`callback()`"+`

## License

MIT
`, projectName, projectName, projectName, projectName, projectName, projectName, projectName, projectName)
}
