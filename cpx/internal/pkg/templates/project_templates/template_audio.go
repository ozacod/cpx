package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&AudioTemplate{})
}

// AudioTemplate generates an audio application with miniaudio
type AudioTemplate struct {
	BaseTemplateHelper
}

func (t *AudioTemplate) Name() string {
	return "Audio"
}

func (t *AudioTemplate) Description() string {
	return "Audio application with miniaudio library"
}

func (t *AudioTemplate) Dependencies() []string {
	return []string{"miniaudio"}
}

func (t *AudioTemplate) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"src",
		"audio",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate main.cpp
	mainCpp := t.generateMainCpp(projectName)
	if err := t.WriteFile(projectName, "src/main.cpp", mainCpp); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *AudioTemplate) generateMainCpp(projectName string) string {
	return fmt.Sprintf(`// %s - Audio Application
// Generated by cpx

#define MINIAUDIO_IMPLEMENTATION
#include <miniaudio.h>
#include <iostream>
#include <cmath>
#include <string>
#include <thread>
#include <chrono>
#include <atomic>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Synthesizer state
struct Synth {
    std::atomic<float> frequency{440.0f};
    std::atomic<float> amplitude{0.3f};
    std::atomic<bool> playing{false};
    double phase = 0.0;
};

Synth synth;

// Audio callback - generates a sine wave
void audioCallback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount) {
    (void)pInput;
    float* out = static_cast<float*>(pOutput);
    ma_uint32 sampleRate = pDevice->sampleRate;

    float freq = synth.frequency.load();
    float amp = synth.amplitude.load();
    bool playing = synth.playing.load();

    for (ma_uint32 i = 0; i < frameCount; ++i) {
        float sample = 0.0f;

        if (playing) {
            sample = amp * static_cast<float>(std::sin(synth.phase));
            synth.phase += 2.0 * M_PI * freq / sampleRate;

            if (synth.phase >= 2.0 * M_PI) {
                synth.phase -= 2.0 * M_PI;
            }
        }

        // Stereo output
        out[i * 2 + 0] = sample;  // Left
        out[i * 2 + 1] = sample;  // Right
    }
}

void printHelp() {
    std::cout << "\n%s - Audio Synthesizer\n";
    std::cout << "================================\n";
    std::cout << "Commands:\n";
    std::cout << "  play      - Start playing\n";
    std::cout << "  stop      - Stop playing\n";
    std::cout << "  freq <hz> - Set frequency (20-20000 Hz)\n";
    std::cout << "  vol <0-1> - Set volume\n";
    std::cout << "  note <n>  - Play MIDI note (C4=60)\n";
    std::cout << "  scale     - Play C major scale\n";
    std::cout << "  help      - Show this help\n";
    std::cout << "  quit      - Exit\n";
    std::cout << "================================\n\n";
}

float midiToFreq(int note) {
    return 440.0f * std::pow(2.0f, (note - 69) / 12.0f);
}

void playScale() {
    int notes[] = {60, 62, 64, 65, 67, 69, 71, 72}; // C major scale
    synth.playing = true;

    for (int note : notes) {
        synth.frequency = midiToFreq(note);
        std::cout << "Playing note " << note << " (" << synth.frequency.load() << " Hz)\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(300));
    }

    synth.playing = false;
}

int main() {
    std::cout << "Initializing audio system...\n";

    // Configure audio device
    ma_device_config config = ma_device_config_init(ma_device_type_playback);
    config.playback.format = ma_format_f32;
    config.playback.channels = 2;
    config.sampleRate = 44100;
    config.dataCallback = audioCallback;
    config.pUserData = nullptr;

    ma_device device;
    if (ma_device_init(nullptr, &config, &device) != MA_SUCCESS) {
        std::cerr << "Failed to initialize audio device!\n";
        return 1;
    }

    if (ma_device_start(&device) != MA_SUCCESS) {
        std::cerr << "Failed to start audio device!\n";
        ma_device_uninit(&device);
        return 1;
    }

    std::cout << "Audio device initialized:\n";
    std::cout << "  Sample rate: " << device.sampleRate << " Hz\n";
    std::cout << "  Channels: " << device.playback.channels << "\n";
    std::cout << "  Format: float32\n";

    printHelp();

    // Command loop
    std::string command;
    while (true) {
        std::cout << "> ";
        std::cin >> command;

        if (command == "quit" || command == "exit" || command == "q") {
            break;
        } else if (command == "play") {
            synth.playing = true;
            std::cout << "Playing at " << synth.frequency.load() << " Hz\n";
        } else if (command == "stop") {
            synth.playing = false;
            std::cout << "Stopped\n";
        } else if (command == "freq") {
            float freq;
            std::cin >> freq;
            if (freq >= 20 && freq <= 20000) {
                synth.frequency = freq;
                std::cout << "Frequency set to " << freq << " Hz\n";
            } else {
                std::cout << "Frequency must be between 20 and 20000 Hz\n";
            }
        } else if (command == "vol") {
            float vol;
            std::cin >> vol;
            if (vol >= 0.0f && vol <= 1.0f) {
                synth.amplitude = vol;
                std::cout << "Volume set to " << vol << "\n";
            } else {
                std::cout << "Volume must be between 0 and 1\n";
            }
        } else if (command == "note") {
            int note;
            std::cin >> note;
            if (note >= 0 && note <= 127) {
                synth.frequency = midiToFreq(note);
                synth.playing = true;
                std::cout << "Playing MIDI note " << note << " (" << synth.frequency.load() << " Hz)\n";
            } else {
                std::cout << "MIDI note must be between 0 and 127\n";
            }
        } else if (command == "scale") {
            playScale();
        } else if (command == "help") {
            printHelp();
        } else {
            std::cout << "Unknown command. Type 'help' for available commands.\n";
        }
    }

    synth.playing = false;
    ma_device_uninit(&device);
    std::cout << "Goodbye!\n";

    return 0;
}
`, projectName, projectName)
}

func (t *AudioTemplate) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find miniaudio
find_path(MINIAUDIO_INCLUDE_DIRS "miniaudio.h")

# Add executable
add_executable(${PROJECT_NAME}
    src/main.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${MINIAUDIO_INCLUDE_DIRS}
)

# Platform-specific audio libraries
if(WIN32)
    target_link_libraries(${PROJECT_NAME} PRIVATE ole32 winmm)
elseif(APPLE)
    find_library(COREAUDIO_LIBRARY CoreAudio)
    find_library(COREFOUNDATION_LIBRARY CoreFoundation)
    find_library(AUDIOTOOLBOX_LIBRARY AudioToolbox)
    target_link_libraries(${PROJECT_NAME} PRIVATE
        ${COREAUDIO_LIBRARY}
        ${COREFOUNDATION_LIBRARY}
        ${AUDIOTOOLBOX_LIBRARY}
    )
elseif(UNIX)
    find_package(Threads REQUIRED)
    target_link_libraries(${PROJECT_NAME} PRIVATE
        Threads::Threads
        ${CMAKE_DL_LIBS}
        m
    )
endif()

# Copy compile_commands.json to project root
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_BINARY_DIR}/compile_commands.json
        ${CMAKE_SOURCE_DIR}/compile_commands.json
    )
endif()
`, projectName, cppStandard)
}

func (t *AudioTemplate) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

An audio application built with miniaudio - a single-header audio library.

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Running

`+"```"+`bash
cpx run
`+"```"+`

## Features

- Real-time audio synthesis
- Interactive command-line interface
- Sine wave oscillator
- MIDI note support
- Volume control
- Cross-platform (Windows, Linux, macOS)

## Commands

| Command | Description |
|---------|-------------|
| play | Start playing the oscillator |
| stop | Stop playing |
| freq \<hz\> | Set frequency (20-20000 Hz) |
| vol \<0-1\> | Set volume (0.0 to 1.0) |
| note \<n\> | Play MIDI note (C4 = 60) |
| scale | Play C major scale |
| help | Show help |
| quit | Exit application |

## Example Session

`+"```"+`bash
> play
Playing at 440 Hz
> freq 880
Frequency set to 880 Hz
> note 60
Playing MIDI note 60 (261.626 Hz)
> scale
Playing note 60 (261.626 Hz)
Playing note 62 (293.665 Hz)
...
> quit
`+"```"+`

## Dependencies

- miniaudio (header-only)

## Extending

You can extend this synthesizer with:
- Different waveforms (square, saw, triangle)
- ADSR envelope
- Multiple oscillators
- Audio file playback
- Recording functionality
- Effects (reverb, delay, filter)

## License

MIT
`, projectName)
}
