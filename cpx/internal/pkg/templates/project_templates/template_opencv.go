package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&OpenCVTemplate{})
}

// OpenCVTemplate generates a computer vision application with OpenCV
type OpenCVTemplate struct {
	BaseTemplateHelper
}

func (t *OpenCVTemplate) Name() string {
	return "OpenCV"
}

func (t *OpenCVTemplate) Description() string {
	return "Computer vision application with OpenCV"
}

func (t *OpenCVTemplate) Dependencies() []string {
	return []string{"opencv4"}
}

func (t *OpenCVTemplate) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"src",
		"images",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate main.cpp
	mainCpp := t.generateMainCpp(projectName)
	if err := t.WriteFile(projectName, "src/main.cpp", mainCpp); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *OpenCVTemplate) generateMainCpp(projectName string) string {
	return fmt.Sprintf(`// %s - OpenCV Application
// Generated by cpx

#include <opencv2/opencv.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>

void createGradientImage(cv::Mat& image) {
    for (int y = 0; y < image.rows; ++y) {
        for (int x = 0; x < image.cols; ++x) {
            image.at<cv::Vec3b>(y, x) = cv::Vec3b(
                static_cast<uchar>(x * 255 / image.cols),
                static_cast<uchar>(y * 255 / image.rows),
                static_cast<uchar>((x + y) * 255 / (image.cols + image.rows))
            );
        }
    }
}

void applyEffects(const cv::Mat& input, cv::Mat& output, int effectType) {
    switch (effectType %% 4) {
        case 0:
            // Gaussian blur
            cv::GaussianBlur(input, output, cv::Size(15, 15), 0);
            break;
        case 1:
            // Canny edge detection
            cv::cvtColor(input, output, cv::COLOR_BGR2GRAY);
            cv::Canny(output, output, 50, 150);
            cv::cvtColor(output, output, cv::COLOR_GRAY2BGR);
            break;
        case 2:
            // Grayscale
            cv::cvtColor(input, output, cv::COLOR_BGR2GRAY);
            cv::cvtColor(output, output, cv::COLOR_GRAY2BGR);
            break;
        case 3:
            // Invert colors
            cv::bitwise_not(input, output);
            break;
    }
}

int main(int argc, char** argv) {
    std::cout << "OpenCV version: " << CV_VERSION << std::endl;
    std::cout << "Welcome to %s!" << std::endl;

    // Create a blank image
    cv::Mat image(480, 640, CV_8UC3, cv::Scalar(30, 30, 40));
    cv::Mat processed;

    // If an image path is provided, load it
    if (argc > 1) {
        cv::Mat loaded = cv::imread(argv[1]);
        if (!loaded.empty()) {
            image = loaded;
            std::cout << "Loaded image: " << argv[1] << std::endl;
        } else {
            std::cerr << "Could not load image: " << argv[1] << std::endl;
            createGradientImage(image);
        }
    } else {
        createGradientImage(image);
    }

    int effectType = 0;
    const char* windowName = "%s";

    cv::namedWindow(windowName, cv::WINDOW_AUTOSIZE);

    std::cout << "\nControls:" << std::endl;
    std::cout << "  SPACE: Cycle through effects" << std::endl;
    std::cout << "  S: Save current image" << std::endl;
    std::cout << "  R: Reset to original" << std::endl;
    std::cout << "  ESC/Q: Quit" << std::endl;

    while (true) {
        // Apply current effect
        applyEffects(image, processed, effectType);

        // Add info text
        std::string effectName;
        switch (effectType %% 4) {
            case 0: effectName = "Gaussian Blur"; break;
            case 1: effectName = "Canny Edges"; break;
            case 2: effectName = "Grayscale"; break;
            case 3: effectName = "Inverted"; break;
        }
        cv::putText(processed, "Effect: " + effectName, cv::Point(10, 30),
                    cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 255, 0), 2);
        cv::putText(processed, "Press SPACE to change effect", cv::Point(10, 60),
                    cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);

        cv::imshow(windowName, processed);

        int key = cv::waitKey(30);
        if (key == 27 || key == 'q' || key == 'Q') {
            break;
        } else if (key == ' ') {
            effectType++;
            std::cout << "Switched to effect: " << effectName << std::endl;
        } else if (key == 's' || key == 'S') {
            cv::imwrite("output.png", processed);
            std::cout << "Saved to output.png" << std::endl;
        } else if (key == 'r' || key == 'R') {
            if (argc > 1) {
                cv::Mat loaded = cv::imread(argv[1]);
                if (!loaded.empty()) {
                    image = loaded;
                }
            } else {
                createGradientImage(image);
            }
            std::cout << "Reset to original" << std::endl;
        }
    }

    cv::destroyAllWindows();
    return 0;
}
`, projectName, projectName, projectName)
}

func (t *OpenCVTemplate) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find OpenCV
find_package(OpenCV CONFIG REQUIRED)

# Add executable
add_executable(${PROJECT_NAME}
    src/main.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(${PROJECT_NAME} PRIVATE
    ${OpenCV_LIBS}
)

# Copy compile_commands.json to project root
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_BINARY_DIR}/compile_commands.json
        ${CMAKE_SOURCE_DIR}/compile_commands.json
    )
endif()
`, projectName, cppStandard)
}

func (t *OpenCVTemplate) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

A computer vision application built with OpenCV.

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Running

`+"```"+`bash
# Run with generated gradient image
cpx run

# Or load your own image
./build/%s path/to/image.jpg
`+"```"+`

## Features

- Image loading and display
- Real-time image processing effects:
  - Gaussian blur
  - Canny edge detection
  - Grayscale conversion
  - Color inversion
- Interactive controls
- Image saving

## Controls

- **SPACE**: Cycle through effects
- **S**: Save current processed image
- **R**: Reset to original image
- **ESC/Q**: Quit application

## Dependencies

- OpenCV 4.x

## OpenCV Modules Used

- **core**: Basic structures and operations
- **imgproc**: Image processing
- **highgui**: GUI and image I/O

## Example Use Cases

- Image filtering and enhancement
- Edge detection
- Feature detection
- Object recognition (extend with additional modules)

## License

MIT
`, projectName, projectName)
}
