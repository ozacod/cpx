package config

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// CIConfig represents the cpx-ci.yaml structure for cross-compilation
type CIConfig struct {
	Targets []CITarget `yaml:"targets"`
	Build   CIBuild    `yaml:"build"`
	Output  string     `yaml:"output"`
}

// DockerBuildConfig represents Docker build configuration for "build" mode
type DockerBuildConfig struct {
	Context    string            `yaml:"context,omitempty"`
	Dockerfile string            `yaml:"dockerfile,omitempty"`
	Args       map[string]string `yaml:"args,omitempty"`
}

// DockerConfig represents Docker runner configuration
type DockerConfig struct {
	Mode       string             `yaml:"mode"`                 // pull, local, build
	Image      string             `yaml:"image"`                // image name or tag for build result
	Platform   string             `yaml:"platform,omitempty"`   // e.g., linux/amd64, linux/arm64
	PullPolicy string             `yaml:"pullPolicy,omitempty"` // always, never, ifNotPresent
	Build      *DockerBuildConfig `yaml:"build,omitempty"`      // only for mode: build
}

// CITarget represents a cross-compilation target
type CITarget struct {
	Name   string            `yaml:"name"`
	Active *bool             `yaml:"active,omitempty"` // true (default) or false to disable target
	Runner string            `yaml:"runner,omitempty"` // docker (default), native
	Docker *DockerConfig     `yaml:"docker,omitempty"`
	Env    map[string]string `yaml:"env,omitempty"` // environment variables

	// Per-target build configuration (overrides global build config)
	BuildType    string   `yaml:"build_type,omitempty"`    // Debug, Release, RelWithDebInfo, MinSizeRel
	CMakeOptions []string `yaml:"cmake_options,omitempty"` // additional CMake arguments
	BuildOptions []string `yaml:"build_options,omitempty"` // additional build arguments (cmake --build args)
}

// IsActive returns whether the target is active (defaults to true if not specified)
func (t *CITarget) IsActive() bool {
	if t.Active == nil {
		return true // default to active
	}
	return *t.Active
}

// CIBuild represents CI build configuration
type CIBuild struct {
	Type         string   `yaml:"type"`
	Optimization string   `yaml:"optimization"`
	Jobs         int      `yaml:"jobs"`
	CMakeArgs    []string `yaml:"cmake_args"`
	BuildArgs    []string `yaml:"build_args"`
	MesonArgs    []string `yaml:"meson_args"`
}

// LoadCI loads the CI configuration from cpx-ci.yaml
func LoadCI(path string) (*CIConfig, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config CIConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse cpx-ci.yaml: %w", err)
	}

	// Set defaults for build config
	if config.Output == "" {
		config.Output = filepath.Join(".bin", "ci")
	}
	if config.Build.Type == "" {
		config.Build.Type = "Release"
	}
	if config.Build.Optimization == "" {
		config.Build.Optimization = "2"
	}

	// Set defaults for each target
	for i := range config.Targets {
		// Default runner is docker
		if config.Targets[i].Runner == "" {
			config.Targets[i].Runner = "docker"
		}

		// Default build type is Release
		if config.Targets[i].BuildType == "" {
			config.Targets[i].BuildType = "Release"
		}

		// Set Docker defaults for docker runner
		if config.Targets[i].Runner == "docker" && config.Targets[i].Docker != nil {
			// Default mode is pull
			if config.Targets[i].Docker.Mode == "" {
				config.Targets[i].Docker.Mode = "pull"
			}
			// Default pullPolicy is ifNotPresent
			if config.Targets[i].Docker.PullPolicy == "" {
				config.Targets[i].Docker.PullPolicy = "ifNotPresent"
			}
		}
	}

	return &config, nil
}

// SaveCI saves the CI configuration to cpx-ci.yaml
func SaveCI(config *CIConfig, path string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal cpx-ci.yaml: %w", err)
	}

	// Add header comment
	header := "# cpx-ci.yaml - Cross-compilation configuration\n# Generated by cpx ci add-target\n\n"
	content := header + string(data)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write cpx-ci.yaml: %w", err)
	}

	return nil
}
