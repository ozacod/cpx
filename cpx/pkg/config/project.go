package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// CIConfig represents the cpx.ci structure for cross-compilation
type CIConfig struct {
	Targets []CITarget `yaml:"targets"`
	Build   CIBuild    `yaml:"build"`
	Output  string     `yaml:"output"`
}

// CITarget represents a cross-compilation target
type CITarget struct {
	Name   string `yaml:"name,omitempty"`
	Source string `yaml:"image"`
	Tag    string `yaml:"tag,omitempty"`
}

// CIBuild represents CI build configuration
type CIBuild struct {
	Type         string   `yaml:"type"`
	Optimization string   `yaml:"optimization"`
	Jobs         int      `yaml:"jobs"`
	CMakeArgs    []string `yaml:"cmake_args"`
	BuildArgs    []string `yaml:"build_args"`
	MesonArgs    []string `yaml:"meson_args"`
}

// LoadCI loads the CI configuration from cpx.ci
func LoadCI(path string) (*CIConfig, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config CIConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse cpx.ci: %w", err)
	}

	// Set defaults
	if config.Output == "" {
		config.Output = filepath.Join(".bin", "ci")
	}
	if config.Build.Type == "" {
		config.Build.Type = "Release"
	}
	if config.Build.Optimization == "" {
		config.Build.Optimization = "2"
	}

	// Derive name from image if not specified
	for i := range config.Targets {
		if config.Targets[i].Name == "" && config.Targets[i].Source != "" {
			name := config.Targets[i].Source
			name = strings.TrimPrefix(name, "Dockerfile.")
			config.Targets[i].Name = name
		}
	}

	// Derive tag from target name if not specified
	for i := range config.Targets {
		if config.Targets[i].Tag == "" {
			config.Targets[i].Tag = "cpx-" + config.Targets[i].Name
		}
	}

	return &config, nil
}

// SaveCI saves the CI configuration to cpx.ci
func SaveCI(config *CIConfig, path string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal cpx.ci: %w", err)
	}

	// Add header comment
	header := "# cpx.ci - Cross-compilation configuration\n# Generated by cpx ci add-target\n\n"
	content := header + string(data)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write cpx.ci: %w", err)
	}

	return nil
}
